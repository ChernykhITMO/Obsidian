using Itmo.ObjectOrientedProgramming.Lab2;

using Itmo.ObjectOrientedProgramming.Lab2.Laboratory;

using Itmo.ObjectOrientedProgramming.Lab2.Lecture;

using Itmo.ObjectOrientedProgramming.Lab2.Repository;

using Itmo.ObjectOrientedProgramming.Lab2.Subjects;

using Itmo.ObjectOrientedProgramming.Lab2.SubjectsUpdaters;

using Xunit;

namespace Lab2.Tests;

public class AbstractUniversityTests

{

[Fact]

public void Scenario1()

{

var user = new User(1, "Number1");

var user2 = new User(2, "Number2");

var repositorySubject = new InMemoryRepository<Subject>();

var subjectBuilder = new SubjectBuilder();

Subject subject = subjectBuilder

.AddLaboratoryWork(new LaboratoryWork(3200, "OOP", user, "SOLID", 20, CreditFormat.Exam))

.AddLaboratoryWork(new LaboratoryWork(3200, "OOP", user, "SOLID", 30, CreditFormat.Exam))

.AddLaboratoryWork(new LaboratoryWork(3200, "OOP", user, "SOLID", 50, CreditFormat.Exam))

.AddLectureMaterial(new LectureMaterial(3300, "Introduction to C#", user, "Basics of C# programming", "Content"))

.SetExamFormat(30)

.Build(3400, "Programming", user, "C#");

repositorySubject.Add(subject);

var subjectValidator = new SubjectValidator();

ResultType<Subject> validationResult = subjectValidator.Validate(subject);

Assert.True(validationResult.IsSuccess);

SubjectUpdaterWithBuilder subjectUpdater = new SubjectUpdaterWithBuilder(subject)

.SetDescription("Updated description by unauthorized user");

var updater = new SubjectUpdater(subjectUpdater);

ResultType<Subject> updateResult = updater.Update(subject, user2);

Assert.False(updateResult.IsSuccess);

Assert.Equal("Author must be the same.", updateResult.Error);

var laboratoryWork = new LaboratoryWork(1, "OOP", user, "SOLID", 20, CreditFormat.Exam);

var repositoryLaboratory = new InMemoryRepository<LaboratoryWork>();

repositoryLaboratory.Add(laboratoryWork);

LaboratoryUpdaterBuilder laboratoryUpdate = new LaboratoryUpdaterBuilder(laboratoryWork)

.SetName("Laboratory name Update");

var laboratoryUpdater = new LaboratoryWorkUpdater(laboratoryUpdate);

ResultType<LaboratoryWork> laboratoryWorkUpdateResult = laboratoryUpdater.Update(laboratoryWork, user2);

Assert.False(laboratoryWorkUpdateResult.IsSuccess);

var lectureMaterial = new LectureMaterial(3300, "Lection", user, "Introduction to C# programming", "Content");

var repositoryLectureMaterial = new InMemoryRepository<LectureMaterial>();

repositoryLectureMaterial.Add(lectureMaterial);

LectureUpdaterBuilder lectureUpdaterBuilder = new LectureUpdaterBuilder(lectureMaterial)

.SetContent("New content from C# programming");

var lectureMaterialUpdater = new LectureMaterialUpdater(lectureUpdaterBuilder);

ResultType<LectureMaterial> lectureMaterialUpdateResult = lectureMaterialUpdater.Update(lectureMaterial, user2);

Assert.False(lectureMaterialUpdateResult.IsSuccess);

}

[Fact]

public void Scenario2()

{

var user = new User(1, "Number1");

var subjectBuilder = new SubjectBuilder();

Subject subject = subjectBuilder

.AddLaboratoryWork(new LaboratoryWork(3200, "OOP", user, "SOLID", 20, CreditFormat.Exam))

.AddLaboratoryWork(new LaboratoryWork(3200, "OOP", user, "SOLID", 30, CreditFormat.Exam))

.AddLaboratoryWork(new LaboratoryWork(3200, "OOP", user, "SOLID", 50, CreditFormat.Exam))

.AddLectureMaterial(new LectureMaterial(3300, "Introduction to C#", user, "Basics of C# programming", "Content"))

.SetExamFormat(30)

.Build(3400, "Programming", user, "C#");

var subjectValidator = new SubjectValidator();

ResultType<Subject> validationResult = subjectValidator.Validate(subject);

Assert.True(validationResult.IsSuccess);

var labWork = new LaboratoryWork(3300, "OOP", user, "GRASP", 30, CreditFormat.Exam);

var lectureMaterial = new LectureMaterial(6600, "Lecture", user, "Patterns", "Content");

var repositorySubjects = new InMemoryRepository<Subject>();

repositorySubjects.Add(subject);

var repositoryLaboratoryWork = new InMemoryRepository<LaboratoryWork>();

repositoryLaboratoryWork.Add(labWork);

var repositoryLectureMaterial = new InMemoryRepository<LectureMaterial>();

repositoryLectureMaterial.Add(lectureMaterial);

Subject subject2 = subject.Clone();

LaboratoryWork labWork2 = labWork.Clone();

LectureMaterial lectureMaterial2 = lectureMaterial.Clone();

Assert.Equal(subject.Id, subject2.OriginalId);

Assert.Equal(labWork.Id, labWork2.OriginalId);

Assert.Equal(lectureMaterial.Id, lectureMaterial2.OriginalId);

}

[Fact]

public void Scenario3()

{

var user = new User(1, "Number1");

var subjectBuilder = new SubjectBuilder();

Subject subject = subjectBuilder

.AddLaboratoryWork(new LaboratoryWork(3200, "OOP", user, "SOLID", 50, CreditFormat.Exam))

.AddLaboratoryWork(new LaboratoryWork(3201, "OOP", user, "GRASP", 60, CreditFormat.Exam))

.AddLectureMaterial(new LectureMaterial(3300, "Introduction to C#", user, "Basics of C# programming", "Content"))

.SetExamFormat(100)

.Build(3400, "Programming", user, "C#");

var repositorySubjects = new InMemoryRepository<Subject>();

repositorySubjects.Add(subject);

var subjectValidator = new SubjectValidator();

ResultType<Subject> validationResult = subjectValidator.Validate(subject);

Assert.False(validationResult.IsSuccess);

Assert.Equal("Total points must be 100", validationResult.Error);

}

}

namespace Itmo.ObjectOrientedProgramming.Lab2;

public class User : BaseEntity

{

public User(int id, string name)

{

if (id < 1)

{

throw new ArgumentException("Id must be greater than or equal to 1.");

}

Id = id;

Name = name ?? throw new ArgumentException("Name cannot be null");

}

}

using Itmo.ObjectOrientedProgramming.Lab2.Subjects;

namespace Itmo.ObjectOrientedProgramming.Lab2;

public class SubjectValidator

{

public ResultType<Subject> Validate(Subject subject)

{

int totalPoints = subject.LaboratoryWorks.Sum(lw => lw.Points);

if (totalPoints != 100)

{

return new ResultType<Subject>(null, false, "Total points must be 100");

}

return new ResultType<Subject>(subject, true, string.Empty);

}

}

namespace Itmo.ObjectOrientedProgramming.Lab2;

public interface IUpdater<T>

{

ResultType<T> Update(T entity, User author);

}

namespace Itmo.ObjectOrientedProgramming.Lab2;

public interface IPrototype<T>

{

T Clone();

}

namespace Itmo.ObjectOrientedProgramming.Lab2;

public interface IBuilder<T>

{

T BuildUpdate();

}

namespace Itmo.ObjectOrientedProgramming.Lab2;

public enum CreditFormat

{

Exam,

Credit,

}

namespace Itmo.ObjectOrientedProgramming.Lab2;

public abstract class BaseEntity

{

public int Id { get; set; }

public string? Name { get; set; }

}

using Itmo.ObjectOrientedProgramming.Lab2.Laboratory;

using Itmo.ObjectOrientedProgramming.Lab2.Lecture;

using Itmo.ObjectOrientedProgramming.Lab2.Subjects;

namespace Itmo.ObjectOrientedProgramming.Lab2.SubjectsUpdaters;

public class SubjectUpdaterWithBuilder : BaseEntity, IBuilder<Subject>

{

private readonly Subject _subjects;

private string _description;

private IEnumerable<LaboratoryWork> _laboratoryWorks;

private IEnumerable<LectureMaterial> _lectureMaterials;

private int _id;

private string _name;

public SubjectUpdaterWithBuilder(Subject subject)

{

_subjects = subject;

_description = subject.Description;

_laboratoryWorks = subject.LaboratoryWorks;

_lectureMaterials = subject.LectureMaterials;

_id = subject.Id;

_name = subject.Name ?? throw new ArgumentException("Subject name cannot be null");

}

public SubjectUpdaterWithBuilder SetId(int id)

{

if (id < 1)

{

throw new ArgumentException("Id must be greater than 0");

}

_id = id;

return this;

}

public SubjectUpdaterWithBuilder SetName(string name)

{

if (string.IsNullOrWhiteSpace(name))

{

throw new ArgumentException("Name cannot be empty or whitespace");

}

_name = name;

return this;

}

public SubjectUpdaterWithBuilder SetDescription(string description)

{

_description = description;

return this;

}

public SubjectUpdaterWithBuilder SetLaboratoryWorks(IEnumerable<LaboratoryWork> laboratoryWorks)

{

var labs = laboratoryWorks.ToList();

if (labs.Sum(lab => lab.Points) > 100)

{

throw new ArgumentException("Total points for laboratory works cannot exceed 100");

}

_laboratoryWorks = labs;

return this;

}

public SubjectUpdaterWithBuilder SetLectureMaterials(IEnumerable<LectureMaterial> lectureMaterials)

{

_lectureMaterials = lectureMaterials;

return this;

}

public Subject BuildUpdate()

{

_subjects.Description = _description;

_subjects.LaboratoryWorks = _laboratoryWorks;

_subjects.LectureMaterials = _lectureMaterials;

_subjects.Id = _id;

_subjects.Name = _name;

return _subjects;

}

}

using Itmo.ObjectOrientedProgramming.Lab2.Subjects;

namespace Itmo.ObjectOrientedProgramming.Lab2.SubjectsUpdaters;

public class SubjectUpdater : IUpdater<Subject>

{

private readonly SubjectUpdaterWithBuilder _updater;

public SubjectUpdater(SubjectUpdaterWithBuilder updater)

{

_updater = updater;

}

public ResultType<Subject> Update(Subject entity, User author)

{

if (entity.Author.Id != author.Id)

{

return new ResultType<Subject>(null, false, "Author must be the same.");

}

_updater.BuildUpdate();

return new ResultType<Subject>(entity, true, string.Empty);

}

}

using Itmo.ObjectOrientedProgramming.Lab2.Laboratory;

using Itmo.ObjectOrientedProgramming.Lab2.Lecture;

namespace Itmo.ObjectOrientedProgramming.Lab2.Subjects;

public class SubjectMaterials

{

public IEnumerable<LaboratoryWork> LaboratoryWorks { get; set; }

public IEnumerable<LectureMaterial> LectureMaterials { get; set; }

public SubjectMaterials(IEnumerable<LaboratoryWork> laboratoryWorks, IEnumerable<LectureMaterial> lectureMaterials)

{

LaboratoryWorks = laboratoryWorks;

LectureMaterials = lectureMaterials;

}

}

using Itmo.ObjectOrientedProgramming.Lab2.Laboratory;

using Itmo.ObjectOrientedProgramming.Lab2.Lecture;

namespace Itmo.ObjectOrientedProgramming.Lab2.Subjects;

public class SubjectBuilder

{

private readonly List<LaboratoryWork> _laboratoryWorks = new List<LaboratoryWork>();

private readonly List<LectureMaterial> _lectureMaterials = new List<LectureMaterial>();

private CreditFormat _creditFormat;

private int _points;

private int _minPoints;

private int _originalId;

public SubjectBuilder AddLaboratoryWork(LaboratoryWork laboratoryWork)

{

_laboratoryWorks.Add(laboratoryWork);

return this;

}

public SubjectBuilder AddLectureMaterial(LectureMaterial lecture)

{

_lectureMaterials.Add(lecture);

return this;

}

public SubjectBuilder SetExamFormat(int points)

{

_creditFormat = CreditFormat.Exam;

if (points <= 0)

{

throw new ArgumentException("Must be greater than 0");

}

_points = points;

return this;

}

public SubjectBuilder SetCreditFormat(int minPoints)

{

_creditFormat = CreditFormat.Credit;

if (minPoints <= 0)

{

throw new ArgumentException("MinPoints must be greater than 0");

}

_minPoints = minPoints;

return this;

}

public SubjectBuilder SetOriginalId(int originalId)

{

_originalId = originalId;

return this;

}

public Subject Build(int id, string name, User author, string description)

{

var subject = new Subject(id, name, author, description)

{

OriginalId = _originalId,

LaboratoryWorks = _laboratoryWorks,

LectureMaterials = _lectureMaterials,

CreditFormat = _creditFormat,

};

if (_creditFormat == CreditFormat.Exam)

{

subject.Points = _points;

}

else if (_creditFormat == CreditFormat.Credit)

{

subject.MinPoints = _minPoints;

}

return subject;

}

}

using Itmo.ObjectOrientedProgramming.Lab2.Laboratory;

using Itmo.ObjectOrientedProgramming.Lab2.Lecture;

namespace Itmo.ObjectOrientedProgramming.Lab2.Subjects;

public class Subject : BaseEntity, IPrototype<Subject>

{

public User Author { get; }

public string Description { get; set; }

public IEnumerable<LaboratoryWork> LaboratoryWorks { get; set; }

public IEnumerable<LectureMaterial> LectureMaterials { get; set; }

public CreditFormat CreditFormat { get; set; }

public int Points { get; set; }

public int MinPoints { get; set; }

public int OriginalId { get; set; }

public Subject(int id, string name, User author, string description)

{

if (id < 1)

{

throw new ArgumentException("Subject id must be greater than 0");

}

Id = id;

Name = name;

Author = author;

Description = description ?? throw new ArgumentException("Description cannot be null");

LaboratoryWorks = new List<LaboratoryWork>();

LectureMaterials = new List<LectureMaterial>();

}

public Subject Clone()

{

if (Name == null)

{

throw new ArgumentException("Name cannot be null");

}

var clonedLaboratoryWorks = new List<LaboratoryWork>();

foreach (LaboratoryWork lw in LaboratoryWorks)

{

clonedLaboratoryWorks.Add(lw.Clone());

}

var clonedLectureMaterials = new List<LectureMaterial>();

foreach (LectureMaterial lm in LectureMaterials)

{

clonedLectureMaterials.Add(lm.Clone());

}

return new Subject(Id, Name, Author, Description)

{

OriginalId = this.Id,

CreditFormat = CreditFormat,

Points = Points,

MinPoints = MinPoints,

LaboratoryWorks = clonedLaboratoryWorks,

LectureMaterials = clonedLectureMaterials,

};

}

}

using Itmo.ObjectOrientedProgramming.Lab2.Subjects;

namespace Itmo.ObjectOrientedProgramming.Lab2.Semester;

public class SubjectSemester

{

public Subject Subject { get; }

public int SemesterNumber { get; }

public SubjectSemester(Subject subject, int semesterNumber)

{

Subject = subject;

SemesterNumber = semesterNumber;

}

}

namespace Itmo.ObjectOrientedProgramming.Lab2.Semester;

public class SemesterManager

{

private readonly List<SubjectSemester> _subjectSemesters = new List<SubjectSemester>();

public void AddSubjectSemester(SubjectSemester subjectSemester)

{

_subjectSemesters.Add(subjectSemester);

}

}

namespace Itmo.ObjectOrientedProgramming.Lab2;

public class ResultType<T>

{

public bool IsSuccess { get; }

public string Error { get; set; }

public T? Value { get; }

public ResultType(T? value, bool isSuccess, string error)

{

Value = value;

IsSuccess = isSuccess;

Error = error;

}

public ResultType<T> Success(T value)

{

return new ResultType<T>(value, true, string.Empty);

}

public ResultType<T> Failure(string error)

{

return new ResultType<T>(default, false, error);

}

}

namespace Itmo.ObjectOrientedProgramming.Lab2.Repository;

public interface IRepository<T>

{

ResultType<T> Add(T entity);

ResultType<T> GetById(int id);

IEnumerable<T> GetAll();

}

namespace Itmo.ObjectOrientedProgramming.Lab2.Repository;

public class InMemoryRepository<T> : IRepository<T> where T : BaseEntity

{

private readonly List<T> _entities = new List<T>();

public ResultType<T> Add(T entity)

{

foreach (T ent in _entities)

{

if (ent.Id == entity.Id)

{

return new ResultType<T>(null, false, "Entity already has an assigned ID");

}

}

_entities.Add(entity);

return new ResultType<T>(entity, true, string.Empty);

}

public ResultType<T> GetById(int id)

{

foreach (T entity in _entities)

{

if (entity.Id == id)

return new ResultType<T>(entity, true, string.Empty);

}

return new ResultType<T>(null, false, "Entity not found");

}

public IEnumerable<T> GetAll()

{

return _entities;

}

}

namespace Itmo.ObjectOrientedProgramming.Lab2.Lecture;

public class LectureUpdaterBuilder : BaseEntity, IBuilder<LectureMaterial>

{

private readonly LectureMaterial _lectureMaterial;

private string _description;

private string _content;

private int _id;

private string _name;

public LectureUpdaterBuilder(LectureMaterial lectureMaterial)

{

_lectureMaterial = lectureMaterial;

_description = lectureMaterial.Description;

_content = lectureMaterial.Content;

_id = lectureMaterial.Id;

_name = lectureMaterial.Name ?? throw new ArgumentException("Lecture name cannot be null");

}

public LectureUpdaterBuilder SetId(int id)

{

if (id < 1)

{

throw new ArgumentException("Id must be greater than 0");

}

_id = id;

return this;

}

public LectureUpdaterBuilder SetName(string name)

{

if (string.IsNullOrWhiteSpace(name))

{

throw new ArgumentException("Name cannot be empty or whitespace");

}

_name = name;

return this;

}

public LectureUpdaterBuilder SetDescription(string description)

{

if (string.IsNullOrWhiteSpace(description))

{

throw new ArgumentException("Description cannot be empty or whitespace");

}

_description = description;

return this;

}

public LectureUpdaterBuilder SetContent(string content)

{

if (string.IsNullOrWhiteSpace(content))

{

throw new ArgumentException("Content cannot be empty or whitespace");

}

_content = content;

return this;

}

public LectureMaterial BuildUpdate()

{

_lectureMaterial.Description = _description;

_lectureMaterial.Content = _content;

_lectureMaterial.Id = _id;

_lectureMaterial.Name = _name;

return _lectureMaterial;

}

}

namespace Itmo.ObjectOrientedProgramming.Lab2.Lecture;

public class LectureMaterialUpdater : IUpdater<LectureMaterial>

{

private readonly LectureUpdaterBuilder _updaterBuilder;

public LectureMaterialUpdater(LectureUpdaterBuilder updaterBuilder)

{

_updaterBuilder = updaterBuilder;

}

public ResultType<LectureMaterial> Update(LectureMaterial entity, User author)

{

if (entity.Author.Id != author.Id)

{

return new ResultType<LectureMaterial>(null, false, "Only the author can update the lecture materials.");

}

LectureMaterial updatedEntity = _updaterBuilder.BuildUpdate();

return new ResultType<LectureMaterial>(updatedEntity, true, string.Empty);

}

}

namespace Itmo.ObjectOrientedProgramming.Lab2.Lecture;

public class LectureMaterial : BaseEntity, IPrototype<LectureMaterial>

{

public string Description { get; set; }

public string Content { get; set; }

public User Author { get; }

public int OriginalId { get; set; }

public LectureMaterial(int id, string name, User author, string description, string content)

{

Id = id;

Name = name;

Author = author;

Description = description;

Content = content;

}

public LectureMaterial Clone()

{

if (Name == null)

{

throw new ArgumentException("Name cannot be null");

}

return new LectureMaterial(Id, Name, Author, Description, Content)

{ OriginalId = this.Id, };

}

}

namespace Itmo.ObjectOrientedProgramming.Lab2.Laboratory;

public class LaboratoryWorkUpdater : IUpdater<LaboratoryWork>

{

private readonly LaboratoryUpdaterBuilder _updaterBuilder;

public LaboratoryWorkUpdater(LaboratoryUpdaterBuilder updaterBuilder)

{

_updaterBuilder = updaterBuilder;

}

public ResultType<LaboratoryWork> Update(LaboratoryWork entity, User author)

{

if (entity.Author.Id != author.Id)

{

return new ResultType<LaboratoryWork>(null, false, "Only the author can update the laboratory works.");

}

LaboratoryWork updatedEntity = _updaterBuilder.BuildUpdate();

return new ResultType<LaboratoryWork>(updatedEntity, true, string.Empty);

}

}

namespace Itmo.ObjectOrientedProgramming.Lab2.Laboratory;

public class LaboratoryWork : BaseEntity, IPrototype<LaboratoryWork>

{

public string Description { get; set; }

public int Points { get; set; }

public CreditFormat Criterion { get; set; }

public User Author { get; }

public int? OriginalId { get; set; }

public LaboratoryWork(int id, string name, User author, string description, int points, CreditFormat criterion)

{

Id = id;

Name = name;

Author = author;

Description = description;

Points = points;

Criterion = criterion;

}

public LaboratoryWork Clone()

{

if (Name == null)

{

throw new ArgumentException("Name cannot be null");

}

return new LaboratoryWork(Id, Name, Author, Description, Points, Criterion)

{

OriginalId = this.Id,

};

}

}

namespace Itmo.ObjectOrientedProgramming.Lab2.Laboratory;

public class LaboratoryUpdaterBuilder : BaseEntity, IBuilder<LaboratoryWork>

{

private readonly LaboratoryWork _laboratoryWork;

private string _description;

private int _points;

private CreditFormat _criterion;

private int _id;

private string _name;

public LaboratoryUpdaterBuilder(LaboratoryWork laboratoryWork)

{

_laboratoryWork = laboratoryWork;

_description = laboratoryWork.Description;

_points = laboratoryWork.Points;

_criterion = laboratoryWork.Criterion;

_id = laboratoryWork.Id;

_name = laboratoryWork.Name ?? throw new ArgumentException("Laboratory work name cannot be null");

}

public LaboratoryUpdaterBuilder SetId(int id)

{

if (id < 1)

{

throw new ArgumentException("Id must be greater than 0");

}

_id = id;

return this;

}

public LaboratoryUpdaterBuilder SetName(string name)

{

if (string.IsNullOrWhiteSpace(name))

{

throw new ArgumentException("Name cannot be empty or whitespace");

}

_name = name;

return this;

}

public LaboratoryUpdaterBuilder SetDescription(string description)

{

if (string.IsNullOrWhiteSpace(description))

{

throw new ArgumentException("Description cannot be empty or whitespace");

}

_description = description;

return this;

}

public LaboratoryUpdaterBuilder SetPoints(int points)

{

if (points <= 0 || points > 100)

{

throw new ArgumentException("Points value must be between 1 and 100");

}

_points = points;

return this;

}

public LaboratoryUpdaterBuilder SetCriterion(CreditFormat criterion)

{

_criterion = criterion;

return this;

}

public LaboratoryWork BuildUpdate()

{

_laboratoryWork.Description = _description;

_laboratoryWork.Points = _points;

_laboratoryWork.Criterion = _criterion;

_laboratoryWork.Id = _id;

_laboratoryWork.Name = _name;

return _laboratoryWork;

}

}

using Itmo.ObjectOrientedProgramming.Lab2.Semester;

namespace Itmo.ObjectOrientedProgramming.Lab2.Curriculum;

public class EducationProgram : BaseEntity

{

public User ProgramManager { get; }

public int SemesterNumber { get; }

public IEnumerable<SubjectSemester> ProgramSubjects => _programSubjects;

private readonly List<SubjectSemester> _programSubjects;

public EducationProgram(int id, string name, User programManager, IEnumerable<SubjectSemester> programSubjects, int semesterNumber)

{

Id = id;

Name = name;

ProgramManager = programManager;

_programSubjects = programSubjects?.ToList() ?? new List<SubjectSemester>();

SemesterNumber = semesterNumber;

}

public void AddSubjectToSemester(SubjectSemester subject)

{

_programSubjects.Add(subject);

}

}

Лабораторная 2

Отрабатываемый материал

Основные принципы ООП, SOLID, GRASP, порождающие паттерны

Цель

Отработать реализацию порождающих паттернов, применить их совместно с ранее изученным материалом.

Задание

реализовать модель конструктора образовательных программ

покрыть полученное решение тестами

Формулировка

Некоторый абстрактный университет проектирует систему для формирования и редактирования образовательных программ. Вам необходимо спроектировать предметную область для реализации данного функционала.

В системе присутствуют: пользователи, лабораторные, лекционные материалы, критерии оценивания, предметы, сами образовательные программы.

Функциональные требования

Пользователь

Имеет идентификатор и имя

Привязан к последующим создаваемым сущностям в качестве автора

Лабораторная работа

Имеет: идентификатор, наименование, описание, критерии оценивания, количество баллов

Также имеет автора

Лабораторную работу можно создать на основе уже существующей, в таком случае она должна хранить идентификатор лабораторной, взятой за основу

Лабораторная может быть изменена, но сделать это может только её автор

Лекционные материалы

Имеют: идентификатор, наименование, краткое описание, контент (строковый)

Также имеют автора

Лекционные материалы можно создать на основе уже существующих, в таком случае они должны хранить идентификатор лекционных материалов, взятых за основу

Лекционные материалы могут быть изменены, но сделать это может только их автор

Предмет

Имеет: идентификатор, название, список лабораторных работ, список лекционных материалов

Также имеет автора

К предметам привязан зачётный формат: экзамен или зачет

В случае, когда предмет имеет экзамен, он должен содержать количество баллов

В случае, когда предмет имеет зачёт, он должен содержать информацию о минимальном количестве баллов, необходимых для получения этого зачёта

Предмет можно создать на основе уже существующих, в таком случае он должен хранить идентификатор предмета, взятого за основу

Предмет может быть изменён, но сделать это может только его автор

Суммарное количество баллов предмета должно ровнятся 100

Образовательная программа

Имеет: идентификатор, название, список предметов

Предметы должны быть привязаны к определённым семестрам

Также имеет ответственное лицо, руководителя программы

Нефункциональные требования

Реализации создания сущностей на основе предыдущих должны использовать различные порождающие паттерны

Для сущностей должны быть реализованы репозитории, хранящие созданные объекты и осуществляющие поиск по их идентификаторам

При использовании абстракций, не должно быть необходимости указывать автора каждый раз при сборке новых сущностей

Репозиторий – тип, ответсвенный за хранение, добавление и поиск каких-либо сущностей. В данной лабораторной вам необхоимо сделать in-memory реализацию (основанную на листе или словаре, например), которая просто позволяет отслеживать определённые сущности и потом их искать.

Тестовые сценарии

Попытки изменения сущностей не автором – возвращают ошибки

После создания сущностей на основе существующих, копии должны содержать идентификаторы исходника

При создании предмета, с количеством баллов не равное 100 – возвращается ошибка

Определение готовности

реализованы все функциональные и не функциональные требования

реализованы все необходимые юнит-тесты

в реализации лабораторной используются порождающие паттерны

реализация не нарушает принципы SOLID, следует основным концепциям ООП

что скажешь?