## Нормализация  
- приведение БД к неким нормальным формам

## Задачи, которые решает *нормализация*
- уменьшение дублирование информации
- уменьшение объёмов хранения информации 
- исключение **аномалий**(таблица - регион проживания, добавление чуть некорректных данных - аномалия, или аномалия может появиться при изменении/удалении данных)

#### Реакция на аномолию:
- SQL не разрешает
- автоматически заменить на неопределенность
- заменить на базовое значение 
- игнорировать(пусть так и будет)
- каскадные действия(удалить всю пятую категорию)
#### Задача нормализации - уйти от этих аномалий 

## Декомпозиция 
Разбиваем таблицу на две или более, чтобы можно было соединить их обратно без потерь

##### Пример 1 (декомпозиция без потерь)

| Фамилия | Работа | Город |
| ------- | :----: | ----- |
| Иванов  |   HR   | МСК   |
| Петров  |   IT   | СПБ   |
| Сидоров |   IT   | МСК   |
->

| Фамилия | Работа |
| ------- |:------:|
| Иванов  |   HR   |
| Петров  |   IT   |

| Работа | Город |
| ------ | ----- |
| IT     | МСК   |
| HR     | СПБ   |



##### Пример 2 (декомпозиция с потерями)

| Товар | Поставщик | Цена |
|:-----:|:---------:|:----:|
| Лампа |     А     | 100  |
| Лампа |     Б     | 150  |
| Стул  |     А     | 200  |

->

| Товар | Поставщик |
|:-----:|:---------:|
| Лампа |     А     |
| Лампа |     Б     |
| Стул  |     А     |

| Поставщик | Цена |
|:---------:| ---- |
|     А     | 100  |
|     Б     | 150  |
|     А     | 200  |
#####

##### **Зависимость** 
ситуация, в отношении одного атрибута зависит значение другого атрибута
	если знаю значение А, то точно знаю значение Б
	название региона, коррелирует с номером региона

#### **Частичная функциональная зависимость**
-  когда атрибут (не ключевой) зависит от части потенциального ключа

	*Пример*:

| ФИО студента | Группа | Факультет |
| ------------ | ------ |:---------:|
| Иванов И.И   | М3219  |   ИТИП    |

**Потенциальный ключ** - ФИО и номер группы
Факультет зависит от группы
М3219 - гарантировано факультет ИТИП

#### **Полная функциональная зависимость** 
- атрибут зависит от всего потенциального ключа

#### **Транзитивная зависимость** 
-  ситуация, атрибут А определяет атрибут Б и атрибут Б определяет атрибут С

пр. 

####  **Первая нормальная форма** -
гарантия того, что таблица может быть рассмотрена, как отношение 
- **Все строки (кортежи) уникальны** – не может быть одинаковых строк в таблице.
- **Значения в каждой ячейке атомарны** – каждое поле хранит одно значение, а не набор или список.

	Если студент изучает несколько предметов, то в столбце предметов стоит только один предмет 

| Имя  | Предмет    |
| ---- | ---------- |
| Олег | Математика |
| Олег | Русский    |
Пример нарушения атомарности:
- Студент изучает несколько предметов, и мы записали их в одной ячейке:

| Имя  | Предметы           |
| ---- | ------------------ |
| Олег | Математика, Физика |

*Уровень атомарности определяется во многом бизнес логикой* 

#### **Вторая нормальная форма** - 
отношение находится в первой нормальной форме, все атрибуты полно зависят от первичного ключа 
и отсутствуют частичные функциональные зависимости.

##### *Пример соблюдения:*

|Группа|Образовательная программа|Факультет|
|---|---|---|
|M32011|Программирование|ФИТиП|
- Таблица в 1NF — все значения атомарны.
- Все неключевые атрибуты (программа и факультет) зависят от **первичного ключа (Группа)** и **нет частичных зависимостей**

	**Частичные зависимости** возникают в таблицах, где используется **составной ключ** (первичный ключ состоит из нескольких столбцов), и при этом некоторые неключевые атрибуты зависят **только от части этого ключа**, а не от него целиком.

##### *Пример несоблюдения:*

| ID курса | ID студента | Имя студента |  Кружок   |
|:--------:|:-----------:|:------------:|:---------:|
|   100    |      1      |     Иван     |   Лепка   |
|   100    |      2      |     Пётр     |   Лепка   |
|   101    |      1      |     Иван     | Рисование |
	Номер курса и номер студента надо вытащить в отдельную таблицу - **вместе они уникально идентифицируют строку**


Разделяем на:

Таблица "Курсы и студенты"

| ID курса | ID студента |
|:--------:|:-----------:|
|   100    |      1      |
|   100    |      2      |
|   101    |      1      |

Таблица "Студенты"

| ID студента | Имя студента |  Кружок   |
|:-----------:|:------------:|:---------:|
|      1      |     Иван     |   Лепка   |
|      2      |     Пётр     |   Лепка   |


#### **Третья нормальная форма** 
- отношение находится во второй нормальной форме, все не ключевые атрибуты взаимно независимы, т.е. зависят от первичного ключа

Пример соблюдения:

| Ф   | И   | О   | Группа | Форма обучения |
| --- | --- | --- | ------ |:--------------:|
| К.  | И.  | Э.  | M32011 |     Очная      |

|Группа|Образовательная программа|
|---|---|
|M32011|Программирование|

|Образовательная программа|Факультет|
|---|---|
|Программирование|ФИТиП|

Пример несоблюдения:

| ID студента | Имя  | Номер отдела | Отдел |
| :---------: | ---- | :----------: | ----- |
|      1      | Иван |      5       | HR    |
|      2      | Пётр |      6       | IT    |
	 Выносим название отдела, т.к. оно зависит от номера отдела 
	 Номер отдела зависит от ID студента


#### Нормальная форма Бойса-Кодда (==**BCNF**==)
(продолжение третьей нормальной формы) 

Отношение находится **в нормальной форме Бойса-Кодда**, если детерминанты _(зависимые части)_ всех зависимостей являются потенциальными ключами.

**Детерминант** — это поле, значение которого определяет значение другого поля. Например, если "Номер студента" определяет "ФИО", то "Номер студента" — детерминант.

**Пример**

|Номер студента|ФИО|Номер проекта|Роль|
|---|---|---|---|
|307484|Кудашев И.|1|Бекенд|
###### Почему тут нарушение BCNF?

- Детерминант — **"Номер студента"** определяет **"ФИО"**.
- Но **"Номер проекта"** тоже участвует в определении **"Роли"**.  
Здесь **ни "Номер студента", ни "Номер проекта" не являются полными ключами**, если рассматривать их по отдельности.

###### Приведение к нормальной форме Бойса-Кодда

|Студент|Номер студента|ФИО|
|---|---|---|
|Кудашев|307484|К. И. Э.|
###### Почему теперь в BCNF?

- В первой таблице:
- "Номер студента" — ключ, который однозначно определяет "ФИО".

- Во второй таблице:
- Комбинация **"Номер студента" + "Номер проекта"** —составной ключ, который определяет "Роль".

| Номер студента | Номер проекта | Роль   |
| -------------- | ------------- | ------ |
| 307484         | 1             | Бекенд |



#### **Четвёртая нормальная форма** 
- ситуация, когда таблица находится в BCNF и отсутствуют многозначные зависимости 

*Пример нарушения:*

| Преподаватель | Предмет    | Язык       |
| ------------- | ---------- | ---------- |
| Иванов        | Математика | Русский    |
| Иванов        | Математика | Английский |
| Иванов        | Физика     | Русский    |
| Ивано         | Физика     | Английский |
*Проблема*:

- Предмет и язык преподавания **независимы** друг от друга.
- Иванов может вести **каждый предмет** на **нескольких языках**, и это создаёт **многозначные зависимости**.


**Исправление**:

| Преподаватель | Предмет    |
| ------------- | ---------- |
| Иванов        | Математика |
| Иванов        | Физика     |

| Преподаватель | Язык       |
| ------------- | ---------- |
| Иванов        | Английский |
| Иванов        | Русский    |
Теперь каждая зависимость хранится *в отдельной таблице*:
В первой таблице: Преподаватель → Предмет.
Во второй таблице: Преподаватель → Язык.

- Это устраняет многозначные зависимости, так как **язык и предмет больше не дублируются в одной таблице**.

#### **Пятая нормальная форма** 
- соединение зависимостей, отношение в четвёртой нормальной форме и не может быть декомпозирована без потери данных

пр 7 в тетради


**Шестая нормальная форма** - отношение в пятой нормальной форме, и каждое непустое отношение не разложимо по соединению 

База временных рядов - набор таблиц, где есть:
- ключ
- начало временного ряда
- конец
- значение 
Общие правила:
Нужно оценить какие операции с БД будем выполнять 

Продуктивная - БД ориентированная на транзакции


## Увеличение производительности 

Вводится понятие Индексов 

Индекс - механизм, который увеличивает производительность, за счёт применения дополнительных хранительных информаций

Все БД по умолчанию индексируются по первичному ключу  - первчиные индексы

Вторичные индексы - посмотроены на полях, отличные от того, что было построено при создании таблицы

Индексы так или иначе строятся на основании деревьев

Индексы могут строить по одному атрибуту(столбцу) или нескольким 

Индексы строятся на строках, удовлетворяющих условию 

Глубина дерева - определяет скорость работы

Индексы крайне затрудняют работу с обновлением, удалением данных - *долго*

Индексы всегда строятся слева направо со строковыми данными(по правилам чтения слов)

Кластерный индекс - таблица, ситуация, когда на нижних листах хранятся фактически строки

Некластерные строки - на нижних листах хранятся ссылки на область, где будут находиться наши данные

Кроме индексов основанных на деревьях, бывают хэш индексы. Значение - адрес на диске, где хранится строчка.

Битовые маски - столбец хранит 3 варианта значения
3 битовых массива 

....


#### Представления 

механизм, который позволяет именовать результат выполнения запросы 

берём запрос и говорим, что он называется так 

Преимущества:
- Нужны для лучшей визуализации данных
- Полезная штука про безопасность (данные только для отдела)
- Обратная совместимсть
- Эмуляция архитектуры 

Представления двух видов:
Классическое(имя запроса) и Материализованное(снимок, данные, которые были на момент создания представления)
пр. 


Плюсы Материлизованного представления:
-  афва
- Обновляемость(через представление можно обновлять данные)
пр. гурпы с 15-19, могу обновить студенту фамилию


Представления используются для улучшения


DataMarts - термин хранилищ данных, исп для визуализации части данных 
-витрина данных в хранилище данных
всего лишь визуализация 
















