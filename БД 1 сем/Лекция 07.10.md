#### 1. Унарная операция 
- проекция которая создаёт новое отношение 
- проекция - вертикальная выборка, исключая дублирование
#### 2. *Выборка*
- содержит только кортежи, удовлетворяющие некоторому условию(т.е. предикаты)
#### 3. Объединение
- R and S, получим все строки которые в R + строки которые в S + все строки которые есть и в R и в S, за исключением дублирования
#### 4. Разность 
-  Из отношения R получим все строки за исключением всех строк, которых нет в S
3 и 4 работают на отношениях, которые удовлетворяют правилу совместности
- одинаковое кол-во атрибутов
- совпадают домены
#### 5. Пересечение
- Те строки из R и S, которые есть одновременно и в R и в S
#### 6. Декартово произведение
- конкатенация 
- все возможные варианты двух отношений R и S 
*Полное декартовое произведение* -  всё со всем
#### 7. Тета соединение 
- Придание здравого смысла"
- соединение, которое представляет собой подмножество кортежей из полного декартового произведения, которое удовлетворяет 
-  ON = ==предикат==
- если тета соединение по признаку равенства - то такое соединение *эквивалентности* 
#### 8. Естественное соединение 
- соединение эквивалентности по общим атрибутам 
#### 9. Левое соединение 
- не только строки 
- но и те строки, где в общем столбце R стоит NULL, т.е. LEFT JOIN
#### 10. Полусоединение 
- строки из R, которые входят в результат соединения R и S
#### 11. Деление
-  ситуация, когда два отношения R и S и берём из отношения R подмножество кортежей, которые определены на атрибуте C, соответвующей коомбинацией всех кортежей С где С множество атрибутов имеющихся в отношение R но отсутствующих в отношение S (JOIN)

На основании этой идеи был создан язык SQL
Язык не процедурный и не комплиируемый
основная идея, описываем какие данные хотим получить, но не описываем, как хотим получать

### Язык состоит из ключевых слов и параметров
Несколько групп
1. Язык, который определяет архитектуру (CREATE)
2. DML - язык манипуляции - Data manipulation language
- модификация данных - INSERT, UPDATE, DELETE
- язык SELECT 
Оператор SELECT представляет собой конструкцию:
- Обязательно к исполнению
"SELECT[DISTINCT | ALL][* | Col.Name[as Name], [...]][InTo Name]
[FROM] TName [INNER | LEFT OUTER | FULL][JOIN] OTable [as new]
ON
[WHERE][COND]
[GROUP BY][ColLIst(exp)][HAVING][COND]
[ORDER BY][Col.LiST/exp][ASC | DESC]

ещё мб RIGHT, CROSS
DISTINCT - не повторяющиеся данные
-  
ALL - до какого-то времени был обязательным
Exp - над столбцом 
InTo Name - результат выполнения селекта будет депонирован в новую таблицу
решётка перед таблицей(#) - временная база

**TempDB** - база, которая хранит временно таблицу(локально)
две решётки - глобально временные до того момента,  пока есть соединение с сервером

TName - имя таблицы (место источника данных

CROSS - полное декартово произведение

RIGHT - зеркало LEFT

Псевдонимы - топ

Чем больше группировок - больше нагрузка

ORDER BY - упорядочиваем по столбцу, либо над результатом операции над этим столбцом
#### Агрегирующие функции 
- выполняются над группой значений атрибутом 
- MAX - максимальное значение в столбце или подгруппе 
- агрегирующие функции можно применять без GROUP BY
- статистические функции - ove

язык R 

##### Порядок выполнения запросов
SQL не процедурный язык, но и не скриптовый язык
 
HTML - скриптовый язык

SQL - сначала анализирует язык, потом структурируется план выполнения запросов

###### Общие правила(порядок выполнения)
1. FROM
2. ON 
3. JOIN
4. WHERE 
5. GROUP BY
6. HAVING 
7. SELECT 
8. DISTINCT
9. ORDER BY

[B дерево](https://neerc.ifmo.ru/wiki/index.php?title=B-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE)









#### Вложенные подзапросы 
##### 1 Блок -  Простые вложенные подзапрос 
SELECT
FROM T1
WHERE ... = (SELECT ..... FROM T2 ...)

##### 2 блок - Кореллирующие подзапросы
SELECT ...
FROM T1 
WHERE ... = (SELECT ..
FROM T2 
WHERE T1.Col = T2.Col)

- нельзя кэшировать 
- дорогой ресурс(работают медленно)

SELECT ..., [..... T1.Col = T2.Col]
from T1










