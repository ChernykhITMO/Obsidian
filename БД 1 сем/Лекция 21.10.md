# Надёжность
- Физическая
- Логическая

Гарантированный доступ к данным 

Физическая надёжность: всевозможные рейды, резервирование компонентов и сетевых систем 

Должны обеспечить резервное копирование данных

3 подхода:

1. Создание полных резервных копий
2. По шагам
Копируются только изменяющиеся файлы
3. Накатывание 

Глубина хранения
Время восстановления из резервной копии

Физическая надёжность - вопрос денег

*Логическую* сложнее

Необходима поддержка предметной области 
Обеспечить согласованность данных
Из одного согласованного в другое 

Пренебрежение нормальными формами
БД может быть не нормализоваана

Транзакция - набор действий, который внешним миром воспринимается, как атомарный
Выполняется целиком или не выполняется вообще
Переводит из одного логического состояния в другое логическое состояние

Журналирование - процесс, когда все наши действия, которые связаны с изменением данных, записываются в отдельный файл в виде запроса
Файл - журнал
необходим, чтобы транзакции работали корректно 
пр 2 тетр

Транзакции заканчиваются двумя действиями
commit or roll back 

Транзакция мб очень длинная - нормальная ситуация 
Транзакцию разбивают на точки сохранения
roll back может быть откачен к части транзакции, а не ко всей

4 свойства транзакции:
1. Атомарность 
 Транзакция не делима (точки сохранения - внутренняя )
 2. Согласованность(из одного в другое, степень согласованности определяется некоторыми формальными правилами)
 пр. деньги с одного счёта сняты на другой
 3. Изоляция - запущено несколько транзакций одновременно, при этом транзакции не видят друг друга и не видят изменений
 Т.е. транзакция не позволяет получить доступ к данным, которые сейчас используются 
 4. Долговечность 
 Если транзакция совершена, то бд целостна 

Проблема транзакций:
Если не предпринять доп меры, то:
1. Проблемы обновлённых данных(несколько транзакций могут последовательно обновлять данные и мы не будем знать, какие были обновления были произведены)
пр. крокодильчик 10 тыс, 9 тыс, 1 тыс и продали, а про 9к не узнает никак покупатель

2. Проблема грязных данных
Могут быть неадекватными 
Другая транзакция эти данные может считать другим способом 
пр. депозит в банке, деньги на счёт возвращаются постепенно
3. Проблема повторного чтения
Если найти самый дорогой продукт, то делаем запрос - это транзакция 
Если в рамках транзакции два запроса о стоимости, то получим проблему повторного чтения
4. Проблема фантомных чтений
Считали 25 строк из таблицы, в рамках этой транзакции сделали ещё запрос и получили 24 строчки(т.е. кортежи могут добавиться/исчезнуть во время транзакций)

Решение проблем - блокировки - закрыть на доступ(транзакции) часть данных для других пользователей
1. Явная блокировка(заблокировать от пользователя)
2. Неявные(от SQL сервера)
блокировки распространяются на отдельные строки(целиком), либо 

блокировать можно целиком таблицу
блокировать можно полностью бд

Монопольная блокировка 
- только транзакция будет иметь доступ к данным(полная блокировка для всех остальных, ни читать, не писать и тд)

Коллективная блокировка 
- Одна транзакция блокирует данные на изменения, но другие могут её читать(шарить)


#### Взаимные блокировки
Регулярно происходят проблема, транзакции регулярно пытаются взаимно блокировать данные 
пр 3 тетр

решение:
1. Построение плана выполнения запросов, SQl сервер пытается построить так, чтобы избежать эту ситуацию 
2. Блокировка по времени

#### 4 уровня изоляции транзакций
1. Незавершённое чтение(когда одна транзакция начала изменять данные, любая другая транзакция будет ждать окончания первой)
2. Завершённое чтение(Если транзакция началась выполняться, то никакая другая не сможет считать затрагиваемые данные)
3. Воспроизводимое чтение(если транзакция читает данные, то никто не вправе изменять эти данные)
4. Сериализуемость(если транзакция работает с определённым набором данных, то никакая любая транзакция не сможет добавить данные, удовлетворяющих условию первой транзакции)

begin tran {имя транзакции} commit/roll back

## Безопасность 
С точки зрения компьютерных систем
Существуют иерархии уровней
- Уровень D - весь хлам, который не B,C и выше, т.е. *отсутствие безопасности*, никто не знает, что творится с безопасности 
- Уровень C - есть идентификация и аутентификация - иницурем объект, который пытается войти, аутентификация - проверяем право на какие-то действия
Ведёт логи(кто зашёл, когда зашёл)
- Уровень С1 - дополнотельно к этому, разделяет пользователей и данные
пр. пользователь имеет идентификатор, данные тоже, нет понятия владения
- Уровень С2 - пользователи отличаются друг от друга - гранулированность с точностью до пользователя
- Уровень B - мандатный доступ - проблема уровня C, что пользователь может разгласить данные, к которым он получил доступ. Тут есть право на распространение
- B1, B2, B3 различаются уровнем паранои
- Уровень A - проверенный дизайн.
На уровне А провертся каждый элемент кода, на этапе поектирования закладывается полностью проверка всех 

Для БД характерны ролевые подходы(C)
Системный админ - раздаёт роли 

Роль:
администратор бэкапов
регулирование пользователей

Пользователь - DBO(Data Base Owner) 
Низший доступ - public 
















